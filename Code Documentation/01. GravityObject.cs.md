# GravityObject.cs
*This class is attached to every game object on which gravity works*

### Variables
* Mass - mass of the object (1 unit ~ 10^9 kg);
* Radius - radius of the object, size of the object depends on that;
* Controller - global attachment GravityObjectsController (works kinda like gravity manager);
* _rigidbody2D - Rigidbody2D, attached to game object;
* listHolder - list of every gravity object script, updated via controller;
* InitialVelocity - velocity at the start of simulation;
* GStaticValue - physical constant value, but multiplied by 10^9 *(that's why our unit of mass is equal to 10^9 kg)*;

### void Start
At start we set up scale of our game object with radius. Also we set up controller and rigidbody. Than we call AddGravityObject on controller. Then we setup mass and velocity to our rigidbody by values provided by user.

### void Update
We loop each GravityObject in the list holder and then calculate and apply the gravity for it.

### void ApplyAndCalculateForce
*arguments: float distance, float mass, Vector2 vectorDist*

![image](https://user-images.githubusercontent.com/20907620/208295006-93237df9-627f-4a33-af25-4e572104affc.png)

Force value is magnitude of the gravity force vector, calculated by formula above. VectorDist is x and y values of distance, by this values distance is calculated via pytagoras.

Gravity force vector direction is the same as distance direction.
Because of that we can build trianagle, where one of the sides is Gravity Force.
``GravityForce = proportionScale * distance``
Because of similarity of both triangles (two other sides are just x and y values of the "main side") by proportion scale we can calculate xGravityForce and yGravityForce.

``xGravityForce = proportionScale * vectorDist.x => xGravityForce = GravityForce/distance * vectorDist.x``
*(the same goes with yGravityForce)*
